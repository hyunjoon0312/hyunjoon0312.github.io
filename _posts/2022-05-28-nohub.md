---
title:  "[LINUX] 10분 완성! nohup 명령어 사용법(feat. &)"
excerpt: "Linux OS에서 자주 사용되는 nohup 명령어 사용법과 &에 대한 설명"
toc: true
toc_sticky: true
toc_label: "목차"

categories:
  - Linux
tags:
  - Linux
---

<p>&nbsp;</p>
이번 포스팅에서는 nohup과 & 는 무엇이고 어떻게 사용해야 하는지에 대해 포스팅 해보려고 합니다. 우리가 Linux 환경에서 스크립트를 짜서 작업을 하다 보면 수 초, 수 분 이내에 완료되는 작업들도 있지만 길게는 몇 시간, 몇 주 동안 실행되어야 하는 작업들도 생기기 마련입니다.    

이때 사용자가 로그아웃을 하는 등 터미널과의 세션이 끊기더라도 내가 실행시킨 스크립트가 중단되지 않고 백그라운드에서 계속 돌 수 있도록 해주는 것이 **nohup** 명령어와 **&** 입니다.  


<p>&nbsp;</p>

# nohup 이란?

로그아웃과 같이 터미널과의 세션이 끊기는 경우에 리눅스에서는 **HUP(Hang up)**이라는 시그널을 해당 세션에서 열려있던 모든 프로세스에 보내서 종료시킵니다. 그런데 이때 프로세스가 이 HUP 시그널을 무시하도록 하는 명령어가 바로 **nohup 명령어** 입니다. 말 그대로 “No! HUP! (HUP을 하지 않겠다)” 는 의미의 정말 적절하고도 직관적인 이름의 명령어인 듯 싶습니다.  



## 사용법

```bash
nohup ./devlife_script.sh
nohup: appending output to `nohup.out`
```

사용법은 아주 간단합니다. 내가 실행시키고자 하는 스크립트 명령어 앞에 **nohup**만 붙여서 실행시켜주면 됩니다. **단, 주의할 점은 실행시킬 스크립트 파일의 권한은 755 이상** 가지고 있어야 합니다.    

이렇게 실행시키면 실행시킨 스크립트의 표준 출력(standard output)이 스크립트가 실행된 경로의 **nohup.out** 파일에 리다이렉션(redirection) 됩니다.    

해당 스크립트가 별도로 로그를 남기지 않는다면 nohup.out 파일을 통해서 현재 해당 스크립트가 어떤 상태인지 확인 할 수 있기 때문에 프로세스 모니터링에 유용하게 사용할 수 있습니다.  



## 표준 출력(Standard output) 변경 하기

실행시킬 스크립트의 표준 출력을 nohup.out이 아닌 다른 이름의 파일이나 다른 위치에 남기고 싶다면 ‘ > ‘ 또는 ‘ >> ‘ 과 같은 리다이렉션을 이용하면 됩니다.  

```bash
$ nohup ./devlife_script.sh > /data/devlife_script_standard_output.out
```

이와 같이 명령어를 실행하면 nohup.out 파일은 생성되지 않고 /data 경로에 devlife_scrpit_standard_output.out 파일에 표준 출력이 리다이렉션 됩니다.  

만약 나는 표준 출력을 별도로 남기고 싶지 않다면, 아래와 같이 /dev/null로 리다이렉션 해주면 표준 출력 파일이 생성되지 않습니다.

```bash
nohup ./devlife_script.sh > /dev/null
```

<p>&nbsp;</p>

# & 이란?

일반적으로 **&**은 and의 의미로 사용하지만 리눅스에서는 명령어 맨 끝에 붙이면 ” **내가 이 명령어는 포그라운드(Foreground)가 아니라 백그라운드(Back ground)로 실행하겠다** ” 라는 뜻 입니다. 

즉, nohup으로 스크립트를 실행시킨다는 것은 터미널과의 세션이 끊겨도 ” **이 스크립트가 계속 해서 백그라운드로 실행되길 원해** ” 라는 의미이기 때문에 스크립트를 애초에 포그라운드로 돌리는 경우는 드물며, 따라서 &와 함께 사용하여 백그라운드로 실행시키는 것입니다.



## 사용법

```bash
./devlife_script.sh &
```

백그라운드 실행 사용법 역시 매우 간단합니다. 실행시키고자 하는 스크립트 맨 끝에 & 만 붙여주면 됩니다. 이렇게 백그라운드로 실행시킨 뒤에 잘 실행되었는지 확인하고 싶다면 아래와 같이 프로세스 리스트를 확인해 볼 수 있습니다.  

```bash
ps -ef | grep devlife_script.sh
```

<p>&nbsp;</p>

# nohup과 & 차이

정리를 해보자면 nohup만 사용하면 스크립트가 포그라운드로 실행되지만 터미널과의 세션 종료시에도 계속 실행되며, &만 사용할 경우에는 백그라운드로 실행되지만 터미널과의 세션 종료시에는 프로세스가 종료된다는 것입니다.  

그런데 두 명령어를 실제로 사용해보신 분들은 약간 의아한 부분이 있으실 수도 있습니다.   



**” 나는 & 만 써서 프로세스를 실행해도 터미널과 세션 종료시에 프로세스가 종료되지 않던데요? “**  



이 부분은 백그라운드로 명령어를 실행시켰을 경우에 터미널과 세션 종료가 되더라도 프로세스는 종료되지 않도록 하는 리눅스 환경 설정이 적용되었기 때문입니다.   

```bash
 shopt | grep huponexit
```



위 명령어를 실행시켰을 때 **huponexit off** 로 출력된다면 백그라운드 실행만으로도 세션 종료시 프로세스는 종료되지 않습니다. 하지만! 현업에서 작업하시는 대부분은 수십 수백대의 리눅스 장비를 사용하고 새로운 장비를 사용할 때 마다 옵션이 어떻게 되어 있나 확인하는 것은 비효율적이기 때문에 **nohup과 &를 같이 사용하는 것을 추천**드립니다.  

```bash
nohup ./devlife_script.sh &
```

<p>&nbsp;</p>

# 표준 출력(Standard output)과 표준 에러(Standard Error)

표준 출력과 표준 에러에 대한 부분은 꼭 필요하진 않지만 알아두면 유용하게 쓸 수 있습니다. 단순히 리다이렉션만으로도 표준 출력을 다른 파일에 쓸 수 있지만 간혹 표준 출력과 표준 에러를 서로 다른 파일에 써서 보기 쉽게 하고 싶을 때도 있을 것입니다. 그럴 때는 아래와 같이 가능 합니다.  

```bash
nohup ./devlife_script.sh 1 > devlife_script_standard_output.out 2 > devlife_script_standard_error.err &
```



여기서 1은 표준 출력을 의미하며 2는 표준 에러를 의미합니다. 따라서 표준 출력은 devlife_script_standard_output.out 파일에 표준 에러는 devlife_script_standard_error.err에 리다이렉션 하겠다는 것 입니다.  

```bash
nohup ./devlife_script.sh > devlife_script_standard.log 2>&1 &
```



위와 같이 2>&1 을 이용하여 표준 출력과 표준 에러를 한 파일에 쓰는 것도 가능합니다.  

<p>&nbsp;</p>

# 백그라운드 프로세스 종료

자 이제 마지막으로 백그라운드로 프로세스를 실행시키는 것까지 성공하였는데, 스크립트에 어떤 로직상 오류가 있어서 현재 백그라운드로 실행 중이 스크립트를 종료해야하는 상황이 있을 수 있습니다. 이때는 앞서 보았던 프로세스 조회하는 방법을 통해 프로세스 ID를 알아낸 뒤에 kill 명령어를 통해 종료할 수 있습니다.  

```bash
#프로세스ID 조회
ps -ef | grep devlife_script.sh

#프로세스 종료
kill -9 <Process ID>
```

<p>&nbsp;</p>

# 참고

- [제타위키 – 리눅스 백그라운드 실행](https://zetawiki.com/wiki/리눅스_백그라운드_실행)
- [제타위키 – nohup](https://zetawiki.com/wiki/리눅스_nohup_사용법)